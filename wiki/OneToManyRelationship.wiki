=Asociace Jedna-k-Více (One-to-Many relationship)=

Tuto asociaci použijeme pokud chceme spojit jednu entitu s více (1:N).

==Vlastněná asociace (Owned relationship)==
Stejné jako u asociace 1:1, akorát místo `ContactInfo` použijeme kolekci.
{{{
@PersistenceCapable
public class ContactInfo {
	@PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
	private Key key;
}

@PersistenceCapable
public class Employee {
@PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
	private Key key;
	
	@Persistent
	private List<ContactInfo> contactInfoSets;
}
}}}

Získání `ContactInfo`:
{{{
	Employee e = entityManager.find(employee.class, id);
	e.getContactInfoSets().size();
}}}
Musíme použít `size()` aby byly položky dostupné i po uzavření transakce.

==Vlastněná obousměrná asociace (Owned bidirectional relationship)==
Obousměrnou asociaci použijeme pokud chceme přistupovat k entitám navzájem (z entity `Employee` chceme získat `ContactInfo` a z entity `ContactInfo` chceme získat `Employee`).

{{{
@PersistenceCapable
public class ContactInfo {
	@PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
	private Key key;
	
	@Persistent
	private Employee employee;
}

@PersistenceCapable
public class Employee {
@PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
	private Key key;
	
	@Persistent(mappedBy = "employee")
	private List<ContactInfo> contactInfoSets;
}
}}}
U entity `ContactInfo` přidáme property `Employee` a ke kolekci v druhé entitě přidáme mapování: `(mappedBy = "jmenoEntity")`.

Získání `Employee` z entity `ContactInfo`:
{{{
	ContactInfo ci = entityManager.find(Contact.class, id);
	ci.getEmployee().getId();
}}}
Obě operace musí být provedeny v transakci a aby se entita `Employee` byla použitelná i po uzavření transakce je nutné na ní zavolat getter.

==Nevlastněná asociace (Unowned relationship)==
Místo kolekce entit použijeme kolekci klíčů entit.
Toto můžeme implementovat těmito způsoby:

===Klíč v potomkovi===
{{{
@PersistenceCapable
public class ContactInfo {
        @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
        private Key key;
        
        private Key employeeKey;
}

@PersistenceCapable
public class Employee {
        @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
        private Key key;
}
}}}
Získání kolekce `ContactInfo` podle klíče z entity `Employee`:
{{{
        Employee e = entityManager.find(Employee.class, id);

        Query query = pm.newQuery(ContactInfo.class);
        query.setFilter("employeeKey == employeeKeyParam");
        query.declareParameters("Key employeeKeyParam");

        List<ContactInfo> results = (List<ContactInfo>) query.execute(e.getKey());
}}}
Jedním dotazem vybereme všechny entity `ContactInfo`.

===Kolekce klíčů v předkovi===
{{{
@PersistenceCapable
public class ContactInfo {
        @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
        private Key key;
}

@PersistenceCapable
public class Employee {
        @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
        private Key key;
        
        @Persistent
        private List<Key> contactInfos;
}
}}}
Získání `ContactInfo` pro každý klíč z kolekce:
{{{
        Employee e = entityManager.find(Employee.class, id);
        for (Key contactInfoKey : e.getContactInfos()) {
                ContactInfo ci = entityManager.find(ContactInfo.class, contactInfoKey);
        }
}}}
Pro každý klíč z kolekce se provede jeden dotaz, tento způsob je méně efektivní.

===Kolekce klíčů v předkovi===
{{{
@PersistenceCapable
public class ContactInfo {
        @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
        private Key key;
}

@PersistenceCapable
public class Employee {
        @PrimaryKey @Persistent(valueStrategy = IdGeneratorStrategy.IDENTITY)
        private Key key;
        
        @Persistent
        private List<Key> contactInfos;
}
}}}
Získání `ContactInfo` pro každý klíč z kolekce:
{{{
        Employee e = entityManager.find(Employee.class, id);
        for (Key contactInfoKey : e.getContactInfos()) {
                ContactInfo ci = entityManager.find(ContactInfo.class, contactInfoKey);
        }
}}}
Pro každý klíč z kolekce se provede jeden dotaz, tento způsob je méně efektivní.